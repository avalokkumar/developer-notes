### Cross-Site Scripting (XSS)

Cross-Site Scripting (XSS) is a type of security vulnerability that allows an attacker to inject malicious scripts into a web page viewed by other users. This can be done by injecting the malicious code into a web page through a vulnerable application, such as a website or web-based application. The malicious script can then be executed by the victim's web browser, allowing the attacker to steal sensitive information, such as cookies, session tokens, or personal data, or to perform actions on behalf of the victim, such as making unauthorized transactions or posting malicious content.

There are two types of XSS attacks:

1. Stored XSS: In this type of attack, the malicious script is stored on the web server and served to all users who visit the affected page. This can happen when user input is not properly validated or sanitized before being stored in a database, or when a web application allows users to upload files, such as images or scripts, that are not properly vetted.

2. Reflected XSS: In this type of attack, the malicious script is sent to the web server as a part of a request and then reflected back to the user in the form of an error message or search result. This can happen when user input is not properly validated or sanitized before being included in a web page.

> For example, consider a website that allows users to post comments on a page. If the website does not properly sanitize user input, an attacker could post a comment containing malicious script, such as:

`<script>alert("XSS Attack!");</script>`

If another user views the page, their web browser will execute the script, displaying an alert box with the message "XSS Attack!".

> Another example, consider a website that has a search feature that displays the search term in the URL of the resulting page. If the website does not properly validate the search term, an attacker could craft a URL containing malicious script, such as:

`http://example.com/search?q=<script>alert("XSS Attack!");</script>`

If a user clicks on the link, their web browser will execute the script, displaying an alert box with the message "XSS Attack!".

#### To prevent XSS attacks, it is important to validate and sanitize user input before it is included in a web page, and to use a Content Security Policy (CSP) to restrict the types of scripts that can be executed by a web browser.

---

### Cross-Site Request Forgery (CSRF)

Cross-Site Request Forgery (CSRF) is a type of security vulnerability that allows an attacker to trick a victim into performing an unwanted action on a website where the victim is currently authenticated. This can be done by sending a specially crafted request, such as an HTTP GET or POST request, to the website using the victim's existing session. The request can be sent through a link, image, or form embedded in a web page, or through a phishing email or instant message.

> For example, consider a website that allows users to transfer money between accounts. If the website does not properly protect against CSRF attacks, an attacker could craft a web page containing a form that transfers money from the victim's account to the attacker's account when the victim visits the page. The form could be embedded in a link or image, or hidden in a phishing email or instant message.

> Another example, consider a website that allows users to change their email address, an attacker could craft a web page that contains a form that will change the email address of the victim's account to the attacker's email address when the victim visits the page.

#### To prevent CSRF attacks, it is important to use anti-CSRF tokens, also known as synchronizer tokens, which are unique and unpredictable values that are generated by the server and included in a web page. These tokens are then included in any subsequent requests and verified by the server to ensure that the request is legitimate. Additionally, using SameSite cookie attribute and setting the value to "strict" or "lax" can prevent CSRF attacks, as the browser will only send the cookie if the request originates from the same domain as the cookie.

It's important to note that, CSRF is a complex security vulnerability and the prevention measures should be implemented based on the requirements and the specific functionality of the website.


> Example of a simple web application that demonstrates a CSRF vulnerability:

```
<!-- change-password.html -->
<form action="change-password.php" method="POST">
  <label for="password">New Password:</label>
  <input type="password" id="password" name="password">
  <input type="submit" value="Change Password">
</form>
```


```
<!-- change-password.php -->
<?php
  $password = $_POST['password'];
  // Update the user's password in the database
  updatePassword($password);
?>
```

In this example, the web application has a page that allows users to change their password. The page contains a form with a single input field for the new password, and a submit button to update the password in the database. However, the application does not properly protect against CSRF attacks.

An attacker could craft a web page containing a form that automatically submits the form and changes the victim's password when the victim visits the page. For example, an attacker could send a link to the victim that contains the following code:

```
<body onload="document.forms[0].submit()">
  <form action="http://example.com/change-password.php" method="POST">
    <input type="hidden" name="password" value="AttackerPassword">
  </form>
</body>
```

When the victim clicks on the link and visits the page, the browser will automatically submit the form, and the victim's password will be changed to "AttackerPassword" without their knowledge.

#### To prevent CSRF attacks, it is important to include a unique and unpredictable token in the form and check the token on the server side before performing any sensitive action, such as updating the password. Here is an example of how this could be implemented in PHP:

```
<!-- change-password.html -->
<form action="change-password.php" method="POST">
  <label for="password">New Password:</label>
  <input type="password" id="password" name="password">
  <input type="hidden" name="csrf_token" value="<?php echo $_SESSION['csrf_token']; ?>">
  <input type="submit" value="Change Password">
</form>
```


```
<!-- change-password.php -->
<?php
  if($_POST['csrf_token'] !== $_SESSION['csrf_token']) {
    // Token is invalid, reject the request
    exit("Invalid Token");
  }
  $password = $_POST['password'];
  // Update the user's password in the database
  updatePassword($password);
  // Regenerate the token for next requests
  $_SESSION['csrf_token'] = generateRandomString();
?>
```




